// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: test.sql

package sqlc

import (
	"context"

	"github.com/annexhq/annex/test"
	"github.com/google/uuid"
)

const createTest = `-- name: CreateTest :one
INSERT INTO tests (id, project, name, has_payload, runner_id, runner_heartbeat_at)
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT (project, name) DO UPDATE
    SET project             = excluded.project,
        name                = excluded.name,
        has_payload         = excluded.has_payload,
        runner_id           = excluded.runner_id,
        runner_heartbeat_at = excluded.runner_heartbeat_at,
        created_at          = now()
RETURNING id, project, name, has_payload, runner_id, runner_heartbeat_at, created_at
`

type CreateTestParams struct {
	ID                uuid.UUID `json:"id"`
	Project           string    `json:"project"`
	Name              string    `json:"name"`
	HasPayload        bool      `json:"has_payload"`
	RunnerID          string    `json:"runner_id"`
	RunnerHeartbeatAt Timestamp `json:"runner_heartbeat_at"`
}

func (q *Queries) CreateTest(ctx context.Context, arg CreateTestParams) (*Test, error) {
	row := q.db.QueryRow(ctx, createTest,
		arg.ID,
		arg.Project,
		arg.Name,
		arg.HasPayload,
		arg.RunnerID,
		arg.RunnerHeartbeatAt,
	)
	var i Test
	err := row.Scan(
		&i.ID,
		&i.Project,
		&i.Name,
		&i.HasPayload,
		&i.RunnerID,
		&i.RunnerHeartbeatAt,
		&i.CreatedAt,
	)
	return &i, err
}

const createTestDefaultPayload = `-- name: CreateTestDefaultPayload :exec
INSERT INTO test_default_payloads (test_id, payload, is_zero)
VALUES ($1, $2, $3)
ON CONFLICT (test_id) DO UPDATE
    SET payload = excluded.payload,
        is_zero = excluded.is_zero
`

type CreateTestDefaultPayloadParams struct {
	TestID  uuid.UUID `json:"test_id"`
	Payload []byte    `json:"payload"`
	IsZero  bool      `json:"is_zero"`
}

func (q *Queries) CreateTestDefaultPayload(ctx context.Context, arg CreateTestDefaultPayloadParams) error {
	_, err := q.db.Exec(ctx, createTestDefaultPayload, arg.TestID, arg.Payload, arg.IsZero)
	return err
}

const createTestExecution = `-- name: CreateTestExecution :one
INSERT INTO test_executions (id, test_id, has_payload, scheduled_at)
VALUES ($1, $2, $3, $4)
ON CONFLICT (id) DO UPDATE
    SET test_id      = excluded.test_id,
        has_payload  = excluded.has_payload,
        scheduled_at = excluded.scheduled_at,
        started_at   = null,
        finished_at  = null,
        error        = null
RETURNING id, test_id, has_payload, scheduled_at, started_at, finished_at, error
`

type CreateTestExecutionParams struct {
	ID          test.TestExecutionID `json:"id"`
	TestID      uuid.UUID            `json:"test_id"`
	HasPayload  bool                 `json:"has_payload"`
	ScheduledAt Timestamp            `json:"scheduled_at"`
}

func (q *Queries) CreateTestExecution(ctx context.Context, arg CreateTestExecutionParams) (*TestExecution, error) {
	row := q.db.QueryRow(ctx, createTestExecution,
		arg.ID,
		arg.TestID,
		arg.HasPayload,
		arg.ScheduledAt,
	)
	var i TestExecution
	err := row.Scan(
		&i.ID,
		&i.TestID,
		&i.HasPayload,
		&i.ScheduledAt,
		&i.StartedAt,
		&i.FinishedAt,
		&i.Error,
	)
	return &i, err
}

const createTestExecutionPayload = `-- name: CreateTestExecutionPayload :exec
INSERT INTO test_execution_payloads (test_exec_id, payload)
VALUES ($1, $2)
ON CONFLICT (test_exec_id) DO UPDATE
    SET payload = excluded.payload
`

type CreateTestExecutionPayloadParams struct {
	TestExecID test.TestExecutionID `json:"test_exec_id"`
	Payload    []byte               `json:"payload"`
}

func (q *Queries) CreateTestExecutionPayload(ctx context.Context, arg CreateTestExecutionPayloadParams) error {
	_, err := q.db.Exec(ctx, createTestExecutionPayload, arg.TestExecID, arg.Payload)
	return err
}

const getTest = `-- name: GetTest :one
SELECT id, project, name, has_payload, runner_id, runner_heartbeat_at, created_at
FROM tests
WHERE id = $1
`

func (q *Queries) GetTest(ctx context.Context, id uuid.UUID) (*Test, error) {
	row := q.db.QueryRow(ctx, getTest, id)
	var i Test
	err := row.Scan(
		&i.ID,
		&i.Project,
		&i.Name,
		&i.HasPayload,
		&i.RunnerID,
		&i.RunnerHeartbeatAt,
		&i.CreatedAt,
	)
	return &i, err
}

const getTestByName = `-- name: GetTestByName :one
SELECT id, project, name, has_payload, runner_id, runner_heartbeat_at, created_at
FROM tests
WHERE name = $1
  AND project = $2
`

type GetTestByNameParams struct {
	Name    string `json:"name"`
	Project string `json:"project"`
}

func (q *Queries) GetTestByName(ctx context.Context, arg GetTestByNameParams) (*Test, error) {
	row := q.db.QueryRow(ctx, getTestByName, arg.Name, arg.Project)
	var i Test
	err := row.Scan(
		&i.ID,
		&i.Project,
		&i.Name,
		&i.HasPayload,
		&i.RunnerID,
		&i.RunnerHeartbeatAt,
		&i.CreatedAt,
	)
	return &i, err
}

const getTestDefaultPayload = `-- name: GetTestDefaultPayload :one
SELECT test_id, payload, is_zero
FROM test_default_payloads
WHERE test_id = $1
`

func (q *Queries) GetTestDefaultPayload(ctx context.Context, testID uuid.UUID) (*TestDefaultPayload, error) {
	row := q.db.QueryRow(ctx, getTestDefaultPayload, testID)
	var i TestDefaultPayload
	err := row.Scan(&i.TestID, &i.Payload, &i.IsZero)
	return &i, err
}

const getTestExecution = `-- name: GetTestExecution :one
SELECT id, test_id, has_payload, scheduled_at, started_at, finished_at, error
FROM test_executions
WHERE id = $1
`

func (q *Queries) GetTestExecution(ctx context.Context, id test.TestExecutionID) (*TestExecution, error) {
	row := q.db.QueryRow(ctx, getTestExecution, id)
	var i TestExecution
	err := row.Scan(
		&i.ID,
		&i.TestID,
		&i.HasPayload,
		&i.ScheduledAt,
		&i.StartedAt,
		&i.FinishedAt,
		&i.Error,
	)
	return &i, err
}

const getTestExecutionPayload = `-- name: GetTestExecutionPayload :one
SELECT test_exec_id, payload
FROM test_execution_payloads
WHERE test_exec_id = $1
`

func (q *Queries) GetTestExecutionPayload(ctx context.Context, testExecID test.TestExecutionID) (*TestExecutionPayload, error) {
	row := q.db.QueryRow(ctx, getTestExecutionPayload, testExecID)
	var i TestExecutionPayload
	err := row.Scan(&i.TestExecID, &i.Payload)
	return &i, err
}

const listTestExecutions = `-- name: ListTestExecutions :many
SELECT id, test_id, has_payload, scheduled_at, started_at, finished_at, error
FROM test_executions
WHERE ($1 = test_id)
  AND (
    ($2::timestamp IS NULL AND $3::uuid IS NULL)
        OR (scheduled_at, id) < ($2::timestamp, $3::uuid)
    )
ORDER BY scheduled_at DESC, id DESC
LIMIT ($4::integer)
`

type ListTestExecutionsParams struct {
	TestID          uuid.UUID  `json:"test_id"`
	LastScheduledAt Timestamp  `json:"last_scheduled_at"`
	LastExecID      *uuid.UUID `json:"last_exec_id"`
	PageSize        *int32     `json:"page_size"`
}

func (q *Queries) ListTestExecutions(ctx context.Context, arg ListTestExecutionsParams) ([]*TestExecution, error) {
	rows, err := q.db.Query(ctx, listTestExecutions,
		arg.TestID,
		arg.LastScheduledAt,
		arg.LastExecID,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*TestExecution
	for rows.Next() {
		var i TestExecution
		if err := rows.Scan(
			&i.ID,
			&i.TestID,
			&i.HasPayload,
			&i.ScheduledAt,
			&i.StartedAt,
			&i.FinishedAt,
			&i.Error,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTests = `-- name: ListTests :many
SELECT id, project, name, has_payload, runner_id, runner_heartbeat_at, created_at
FROM tests
`

func (q *Queries) ListTests(ctx context.Context) ([]*Test, error) {
	rows, err := q.db.Query(ctx, listTests)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Test
	for rows.Next() {
		var i Test
		if err := rows.Scan(
			&i.ID,
			&i.Project,
			&i.Name,
			&i.HasPayload,
			&i.RunnerID,
			&i.RunnerHeartbeatAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setTestRunnerHeartbeat = `-- name: SetTestRunnerHeartbeat :exec
UPDATE tests
SET runner_id           = $2,
    runner_heartbeat_at = NOW()
WHERE id = $1
`

type SetTestRunnerHeartbeatParams struct {
	ID       uuid.UUID `json:"id"`
	RunnerID string    `json:"runner_id"`
}

func (q *Queries) SetTestRunnerHeartbeat(ctx context.Context, arg SetTestRunnerHeartbeatParams) error {
	_, err := q.db.Exec(ctx, setTestRunnerHeartbeat, arg.ID, arg.RunnerID)
	return err
}

const updateTestExecutionFinished = `-- name: UpdateTestExecutionFinished :one
UPDATE test_executions
SET finished_at = $2,
    error       = $3
WHERE id = $1
RETURNING id, test_id, has_payload, scheduled_at, started_at, finished_at, error
`

type UpdateTestExecutionFinishedParams struct {
	ID         test.TestExecutionID `json:"id"`
	FinishedAt Timestamp            `json:"finished_at"`
	Error      *string              `json:"error"`
}

func (q *Queries) UpdateTestExecutionFinished(ctx context.Context, arg UpdateTestExecutionFinishedParams) (*TestExecution, error) {
	row := q.db.QueryRow(ctx, updateTestExecutionFinished, arg.ID, arg.FinishedAt, arg.Error)
	var i TestExecution
	err := row.Scan(
		&i.ID,
		&i.TestID,
		&i.HasPayload,
		&i.ScheduledAt,
		&i.StartedAt,
		&i.FinishedAt,
		&i.Error,
	)
	return &i, err
}

const updateTestExecutionStarted = `-- name: UpdateTestExecutionStarted :one
UPDATE test_executions
SET started_at  = $2,
    finished_at = null,
    error       = null
WHERE id = $1
RETURNING id, test_id, has_payload, scheduled_at, started_at, finished_at, error
`

type UpdateTestExecutionStartedParams struct {
	ID        test.TestExecutionID `json:"id"`
	StartedAt Timestamp            `json:"started_at"`
}

func (q *Queries) UpdateTestExecutionStarted(ctx context.Context, arg UpdateTestExecutionStartedParams) (*TestExecution, error) {
	row := q.db.QueryRow(ctx, updateTestExecutionStarted, arg.ID, arg.StartedAt)
	var i TestExecution
	err := row.Scan(
		&i.ID,
		&i.TestID,
		&i.HasPayload,
		&i.ScheduledAt,
		&i.StartedAt,
		&i.FinishedAt,
		&i.Error,
	)
	return &i, err
}
