// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: case.sql

package sqlc

import (
	"context"

	"github.com/annexsh/annex/test"
)

const createCaseExecution = `-- name: CreateCaseExecution :one
INSERT INTO case_executions (id, test_exec_id, case_name, scheduled_at)
VALUES ($1, $2, $3, $4)
ON CONFLICT (id, test_exec_id) DO UPDATE -- safeguard: shouldn't occur in theory
    SET case_name    = excluded.case_name,
        scheduled_at = excluded.scheduled_at,
        started_at   = null,
        finished_at  = null,
        error        = null
RETURNING id, test_exec_id, case_name, scheduled_at, started_at, finished_at, error
`

type CreateCaseExecutionParams struct {
	ID          test.CaseExecutionID `json:"id"`
	TestExecID  test.TestExecutionID `json:"test_exec_id"`
	CaseName    string               `json:"case_name"`
	ScheduledAt Timestamp            `json:"scheduled_at"`
}

func (q *Queries) CreateCaseExecution(ctx context.Context, arg CreateCaseExecutionParams) (*CaseExecution, error) {
	row := q.db.QueryRow(ctx, createCaseExecution,
		arg.ID,
		arg.TestExecID,
		arg.CaseName,
		arg.ScheduledAt,
	)
	var i CaseExecution
	err := row.Scan(
		&i.ID,
		&i.TestExecID,
		&i.CaseName,
		&i.ScheduledAt,
		&i.StartedAt,
		&i.FinishedAt,
		&i.Error,
	)
	return &i, err
}

const deleteCaseExecution = `-- name: DeleteCaseExecution :exec
DELETE
FROM case_executions
WHERE id = $1
  AND test_exec_id = $2
`

type DeleteCaseExecutionParams struct {
	ID         test.CaseExecutionID `json:"id"`
	TestExecID test.TestExecutionID `json:"test_exec_id"`
}

func (q *Queries) DeleteCaseExecution(ctx context.Context, arg DeleteCaseExecutionParams) error {
	_, err := q.db.Exec(ctx, deleteCaseExecution, arg.ID, arg.TestExecID)
	return err
}

const getCaseExecution = `-- name: GetCaseExecution :one
SELECT id, test_exec_id, case_name, scheduled_at, started_at, finished_at, error
FROM case_executions
WHERE id = $1
  AND test_exec_id = $2
`

type GetCaseExecutionParams struct {
	ID         test.CaseExecutionID `json:"id"`
	TestExecID test.TestExecutionID `json:"test_exec_id"`
}

func (q *Queries) GetCaseExecution(ctx context.Context, arg GetCaseExecutionParams) (*CaseExecution, error) {
	row := q.db.QueryRow(ctx, getCaseExecution, arg.ID, arg.TestExecID)
	var i CaseExecution
	err := row.Scan(
		&i.ID,
		&i.TestExecID,
		&i.CaseName,
		&i.ScheduledAt,
		&i.StartedAt,
		&i.FinishedAt,
		&i.Error,
	)
	return &i, err
}

const listTestCaseExecutions = `-- name: ListTestCaseExecutions :many
SELECT id, test_exec_id, case_name, scheduled_at, started_at, finished_at, error
FROM case_executions
WHERE test_exec_id = $1
`

func (q *Queries) ListTestCaseExecutions(ctx context.Context, testExecID test.TestExecutionID) ([]*CaseExecution, error) {
	rows, err := q.db.Query(ctx, listTestCaseExecutions, testExecID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*CaseExecution
	for rows.Next() {
		var i CaseExecution
		if err := rows.Scan(
			&i.ID,
			&i.TestExecID,
			&i.CaseName,
			&i.ScheduledAt,
			&i.StartedAt,
			&i.FinishedAt,
			&i.Error,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resetCaseExecution = `-- name: ResetCaseExecution :one
UPDATE case_executions
SET scheduled_at = null,
    started_at   = null,
    finished_at  = null,
    error        = null
WHERE id = $1
  AND test_exec_id = $2
RETURNING id, test_exec_id, case_name, scheduled_at, started_at, finished_at, error
`

type ResetCaseExecutionParams struct {
	ID         test.CaseExecutionID `json:"id"`
	TestExecID test.TestExecutionID `json:"test_exec_id"`
}

func (q *Queries) ResetCaseExecution(ctx context.Context, arg ResetCaseExecutionParams) (*CaseExecution, error) {
	row := q.db.QueryRow(ctx, resetCaseExecution, arg.ID, arg.TestExecID)
	var i CaseExecution
	err := row.Scan(
		&i.ID,
		&i.TestExecID,
		&i.CaseName,
		&i.ScheduledAt,
		&i.StartedAt,
		&i.FinishedAt,
		&i.Error,
	)
	return &i, err
}

const updateCaseExecutionFinished = `-- name: UpdateCaseExecutionFinished :one
UPDATE case_executions
SET finished_at = $3,
    error       = $4
WHERE id = $1
  AND test_exec_id = $2
RETURNING id, test_exec_id, case_name, scheduled_at, started_at, finished_at, error
`

type UpdateCaseExecutionFinishedParams struct {
	ID         test.CaseExecutionID `json:"id"`
	TestExecID test.TestExecutionID `json:"test_exec_id"`
	FinishedAt Timestamp            `json:"finished_at"`
	Error      *string              `json:"error"`
}

func (q *Queries) UpdateCaseExecutionFinished(ctx context.Context, arg UpdateCaseExecutionFinishedParams) (*CaseExecution, error) {
	row := q.db.QueryRow(ctx, updateCaseExecutionFinished,
		arg.ID,
		arg.TestExecID,
		arg.FinishedAt,
		arg.Error,
	)
	var i CaseExecution
	err := row.Scan(
		&i.ID,
		&i.TestExecID,
		&i.CaseName,
		&i.ScheduledAt,
		&i.StartedAt,
		&i.FinishedAt,
		&i.Error,
	)
	return &i, err
}

const updateCaseExecutionStarted = `-- name: UpdateCaseExecutionStarted :one
UPDATE case_executions
SET started_at = $3
WHERE id = $1
  AND test_exec_id = $2
RETURNING id, test_exec_id, case_name, scheduled_at, started_at, finished_at, error
`

type UpdateCaseExecutionStartedParams struct {
	ID         test.CaseExecutionID `json:"id"`
	TestExecID test.TestExecutionID `json:"test_exec_id"`
	StartedAt  Timestamp            `json:"started_at"`
}

func (q *Queries) UpdateCaseExecutionStarted(ctx context.Context, arg UpdateCaseExecutionStartedParams) (*CaseExecution, error) {
	row := q.db.QueryRow(ctx, updateCaseExecutionStarted, arg.ID, arg.TestExecID, arg.StartedAt)
	var i CaseExecution
	err := row.Scan(
		&i.ID,
		&i.TestExecID,
		&i.CaseName,
		&i.ScheduledAt,
		&i.StartedAt,
		&i.FinishedAt,
		&i.Error,
	)
	return &i, err
}
